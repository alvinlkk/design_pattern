# 设计模式学习
本仓库是针对设计模式的一个集中学习，涵盖了23种设计模式，通过简单的demo例子和jdk中源码来加强我们设计模式的理解。

内容参考的黑马程序员的课程，如果有不理解的，可以在[小破站](https://www.bilibili.com/video/BV1Np4y1z7BU?from=search&seid=3194519713962144067)跟着视频学。

## 介绍

### [设计模式概述](doc/intro.md)

介绍了设计模式产生的背景，设计模式的概念，强调了学习设计模式的必要性。设计模式根据使用场景的不同分为创建型模式、构建型模式和行为型模式。

### [UML](doc/uml.md)

UML，统一建模语言（Unified Modeling Language，UML），用来设计软件的可视化建模语言。主要借了类图，类与类的关联关系，是学习设计模式的基础。

### [软件设计原则](doc/principles.md)

在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。这6条原则分别是开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、迪米特法则和合成复用原则。




## 创建型模式
创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。

这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。

创建型模式分为：

* 单例模式
* 工厂方法模式
* 抽象工程模式
* 原型模式
* 建造者模式

### [单例模式](doc/factory.md)
单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

### [工厂方法模式](doc/factory.md)
工厂模式来创建对象，最大的有点是解耦，满足开闭原则。工厂模式分为简单工厂模式、工厂方法模式和抽象工厂模式。

### [原型模式](doc/prototype.md)
用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。

### [建造者模式](doc/builder.md)
将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。

### 创建者模式对比

#### 工厂方法模式VS建造者模式

工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。

我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。

#### 抽象工厂模式VS建造者模式

抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。

建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。

如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。



## 结构型模式

结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。

由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。

结构型模式分为以下 7 种：

* 代理模式
* 适配器模式
* 装饰者模式
* 桥接模式
* 外观模式
* 组合模式
* 享元模式

### [代理模式](doc/proxy.md)
由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。

